import{DCBOR_INT as h,MT as a,NUMBYTES as u}from"./constants.js";import{DiagnosticSizes as j}from"./options.js";import{sortCoreDeterministic as y}from"./sorts.js";import{box as f,getEncoded as b,saveEncoded as N}from"./box.js";import{defaultEncodeOptions as E,encode as T}from"./encoder.js";import{stringToHex as p,u8concat as S,u8toHex as g}from"./utils.js";import{DecodeStream as I}from"./decodeStream.js";import{Simple as O}from"./simple.js";import{Tag as m}from"./tag.js";import{checkSubnormal as D}from"./float.js";const v=new Map([[u.ZERO,1],[u.ONE,2],[u.TWO,3],[u.FOUR,5],[u.EIGHT,9]]),A=new Uint8Array(0);function k(d,r){return!r.boxed&&!r.preferMap&&d.every(([i])=>typeof i=="string")?Object.fromEntries(d):new Map(d)}class w{static defaultDecodeOptions={...I.defaultOptions,ParentType:w,boxed:!1,cde:!1,dcbor:!1,diagnosticSizes:j.PREFERRED,convertUnsafeIntsToFloat:!1,createObject:k,pretty:!1,preferMap:!1,rejectLargeNegatives:!1,rejectBigInts:!1,rejectDuplicateKeys:!1,rejectFloats:!1,rejectInts:!1,rejectLongLoundNaN:!1,rejectLongFloats:!1,rejectNegativeZero:!1,rejectSimple:!1,rejectStreaming:!1,rejectStringsNotNormalizedAs:null,rejectSubnormals:!1,rejectUndefined:!1,rejectUnsafeFloatInts:!1,saveOriginal:!1,sortKeys:null};static cdeDecodeOptions={cde:!0,rejectStreaming:!0,requirePreferred:!0,sortKeys:y};static dcborDecodeOptions={...this.cdeDecodeOptions,dcbor:!0,convertUnsafeIntsToFloat:!0,rejectDuplicateKeys:!0,rejectLargeNegatives:!0,rejectLongLoundNaN:!0,rejectLongFloats:!0,rejectNegativeZero:!0,rejectSimple:!0,rejectUndefined:!0,rejectUnsafeFloatInts:!0,rejectStringsNotNormalizedAs:"NFC"};parent;mt;ai;left;offset;count=0;children=[];depth=0;#e;#t=null;constructor(r,i,e,t){if([this.mt,this.ai,,this.offset]=r,this.left=i,this.parent=e,this.#e=t,e&&(this.depth=e.depth+1),this.mt===a.MAP&&(this.#e.sortKeys||this.#e.rejectDuplicateKeys)&&(this.#t=[]),this.#e.rejectStreaming&&this.ai===u.INDEFINITE)throw new Error("Streaming not supported")}get isStreaming(){return this.left===1/0}get done(){return this.left===0}static create(r,i,e,t){const[s,l,n,c]=r;switch(s){case a.POS_INT:case a.NEG_INT:{if(e.rejectInts)throw new Error(`Unexpected integer: ${n}`);if(e.rejectLargeNegatives&&n<-0x8000000000000000n)throw new Error(`Invalid 65bit negative number: ${n}`);let o=n;return e.convertUnsafeIntsToFloat&&o>=h.MIN&&o<=h.MAX&&(o=Number(n)),e.boxed?f(o,t.toHere(c)):o}case a.SIMPLE_FLOAT:if(l>u.ONE){if(e.rejectFloats)throw new Error(`Decoding unwanted floating point number: ${n}`);if(e.rejectNegativeZero&&Object.is(n,-0))throw new Error("Decoding negative zero");if(e.rejectLongLoundNaN&&isNaN(n)){const o=t.toHere(c);if(o.length!==3||o[1]!==126||o[2]!==0)throw new Error(`Invalid NaN encoding: "${g(o)}"`)}if(e.rejectSubnormals&&D(t.toHere(c+1)),e.rejectLongFloats){const o=T(n,{chunkSize:9,reduceUnsafeNumbers:e.rejectUnsafeFloatInts});if(o[0]>>5!==s)throw new Error(`Should have been encoded as int, not float: ${n}`);if(o.length<v.get(l))throw new Error(`Number should have been encoded shorter: ${n}`)}if(typeof n=="number"&&e.boxed)return f(n,t.toHere(c))}else{if(e.rejectSimple&&n instanceof O)throw new Error(`Invalid simple value: ${n}`);if(e.rejectUndefined&&n===void 0)throw new Error("Unexpected undefined")}return n;case a.BYTE_STRING:case a.UTF8_STRING:if(n===1/0)return new e.ParentType(r,1/0,i,e);if(e.rejectStringsNotNormalizedAs&&typeof n=="string"){const o=n.normalize(e.rejectStringsNotNormalizedAs);if(n!==o)throw new Error(`String not normalized as "${e.rejectStringsNotNormalizedAs}", got [${p(n)}] instead of [${p(o)}]`)}return e.boxed?f(n,t.toHere(c)):n;case a.ARRAY:return new e.ParentType(r,n,i,e);case a.MAP:return new e.ParentType(r,n*2,i,e);case a.TAG:{const o=new e.ParentType(r,1,i,e);return o.children=new m(n),o}}throw new TypeError(`Invalid major type: ${s}`)}static decodeToEncodeOpts(r){return{...E,avoidInts:r.rejectInts,float64:!r.rejectLongFloats,flushToZero:r.rejectSubnormals,largeNegativeAsBigInt:r.rejectLargeNegatives,sortKeys:r.sortKeys}}push(r,i,e){if(this.children.push(r),this.#t){const t=b(r)||i.toHere(e);this.#t.push(t)}return--this.left}replaceLast(r,i,e){let t,s=-1/0;if(this.children instanceof m?(s=0,t=this.children.contents,this.children.contents=r):(s=this.children.length-1,t=this.children[s],this.children[s]=r),this.#t){const l=b(r)||e.toHere(i.offset);this.#t[s]=l}return t}convert(r){let i;switch(this.mt){case a.ARRAY:i=this.children;break;case a.MAP:{const e=this.#r();if(this.#e.sortKeys){let t;for(const s of e){if(t&&this.#e.sortKeys(t,s)>=0)throw new Error(`Duplicate or out of order key: "0x${s[2]}"`);t=s}}else if(this.#e.rejectDuplicateKeys){const t=new Set;for(const[s,l,n]of e){const c=g(n);if(t.has(c))throw new Error(`Duplicate key: "0x${c}"`);t.add(c)}}i=this.#e.createObject(e,this.#e);break}case a.BYTE_STRING:return S(this.children);case a.UTF8_STRING:{const e=this.children.join("");i=this.#e.boxed?f(e,r.toHere(this.offset)):e;break}case a.TAG:i=this.children.decode(this.#e);break;default:throw new TypeError(`Invalid mt on convert: ${this.mt}`)}return this.#e.saveOriginal&&i&&typeof i=="object"&&N(i,r.toHere(this.offset)),i}#r(){const r=this.children,i=r.length;if(i%2)throw new Error("Missing map value");const e=new Array(i/2);if(this.#t)for(let t=0;t<i;t+=2)e[t>>1]=[r[t],r[t+1],this.#t[t]];else for(let t=0;t<i;t+=2)e[t>>1]=[r[t],r[t+1],A];return e}}export{w as CBORcontainer};
