import{DCBOR_INT as x,MT as s,NUMBYTES as u,SIMPLE as T,SYMS as g,TAG as A}from"./constants.js";import{sortCoreDeterministic as L}from"./sorts.js";import{Writer as N}from"./writer.js";import{box as _,getEncodedLength as G}from"./box.js";import{flushToZero as D,halfToUint as S}from"./float.js";import{hexToU8 as M}from"./utils.js";const{ENCODED:te}=g,O=s.SIMPLE_FLOAT<<5|u.TWO,h=s.SIMPLE_FLOAT<<5|u.FOUR,B=s.SIMPLE_FLOAT<<5|u.EIGHT,C=s.SIMPLE_FLOAT<<5|T.TRUE,j=s.SIMPLE_FLOAT<<5|T.FALSE,W=s.SIMPLE_FLOAT<<5|T.UNDEFINED,P=s.SIMPLE_FLOAT<<5|T.NULL,q=new TextEncoder,k={...N.defaultOptions,avoidInts:!1,cde:!1,collapseBigInts:!0,dcbor:!1,float64:!1,flushToZero:!1,forceEndian:null,ignoreOriginalEncoding:!1,largeNegativeAsBigInt:!1,reduceUnsafeNumbers:!1,rejectBigInts:!1,rejectCustomSimples:!1,rejectDuplicateKeys:!1,rejectFloats:!1,rejectUndefined:!1,simplifyNegativeZero:!1,sortKeys:null,stringNormalization:null},R={cde:!0,ignoreOriginalEncoding:!0,sortKeys:L},$={...R,dcbor:!0,largeNegativeAsBigInt:!0,reduceUnsafeNumbers:!0,rejectCustomSimples:!0,rejectDuplicateKeys:!0,rejectUndefined:!0,simplifyNegativeZero:!0,stringNormalization:"NFC"};function I(e){const n=e<0;return typeof e=="bigint"?[n?-e-1n:e,n]:[n?-e-1:e,n]}function p(e,n,t){if(t.rejectFloats)throw new Error(`Attempt to encode an unwanted floating point number: ${e}`);if(isNaN(e))n.writeUint8(O),n.writeUint16(32256);else if(!t.float64&&Math.fround(e)===e){const r=S(e);r===null?(n.writeUint8(h),n.writeFloat32(e)):(n.writeUint8(O),n.writeUint16(r))}else n.writeUint8(B),n.writeFloat64(e)}function a(e,n,t){const[r,i]=I(e);if(i&&t)throw new TypeError(`Negative size: ${e}`);t??=i?s.NEG_INT:s.POS_INT,t<<=5,r<24?n.writeUint8(t|r):r<=255?(n.writeUint8(t|u.ONE),n.writeUint8(r)):r<=65535?(n.writeUint8(t|u.TWO),n.writeUint16(r)):r<=4294967295?(n.writeUint8(t|u.FOUR),n.writeUint32(r)):(n.writeUint8(t|u.EIGHT),n.writeBigUint64(BigInt(r)))}function U(e,n,t){typeof e=="number"?a(e,n,s.TAG):typeof e=="object"&&!t.ignoreOriginalEncoding&&g.ENCODED in e?n.write(e[g.ENCODED]):e<=Number.MAX_SAFE_INTEGER?a(Number(e),n,s.TAG):(n.writeUint8(s.TAG<<5|u.EIGHT),n.writeBigUint64(BigInt(e)))}function l(e,n,t){const[r,i]=I(e);if(t.collapseBigInts&&(!t.largeNegativeAsBigInt||e>=-0x8000000000000000n)){if(r<=0xffffffffn){a(Number(e),n);return}if(r<=0xffffffffffffffffn){const E=(i?s.NEG_INT:s.POS_INT)<<5;n.writeUint8(E|u.EIGHT),n.writeBigUint64(r);return}}if(t.rejectBigInts)throw new Error(`Attempt to encode unwanted bigint: ${e}`);const o=i?A.NEG_BIGINT:A.POS_BIGINT,d=r.toString(16),f=d.length%2?"0":"";U(o,n,t);const c=M(f+d);a(c.length,n,s.BYTE_STRING),n.write(c)}function z(e,n,t){t.flushToZero&&(e=D(e)),Object.is(e,-0)?t.simplifyNegativeZero?t.avoidInts?p(0,n,t):a(0,n):p(e,n,t):!t.avoidInts&&Number.isSafeInteger(e)?a(e,n):t.reduceUnsafeNumbers&&Math.floor(e)===e&&e>=x.MIN&&e<=x.MAX?l(BigInt(e),n,t):p(e,n,t)}function K(e,n,t){const r=t.stringNormalization?e.normalize(t.stringNormalization):e,i=q.encode(r);a(i.length,n,s.UTF8_STRING),n.write(i)}function H(e,n,t){const r=e;F(r,r.length,s.ARRAY,n,t);for(const i of r)b(i,n,t)}function Z(e,n){const t=e;a(t.length,n,s.BYTE_STRING),n.write(t)}const m=new Map([[Array,H],[Uint8Array,Z]]);function ie(e,n){const t=m.get(e);return m.set(e,n),t}function re(e){const n=m.get(e);return m.delete(e),n}function F(e,n,t,r,i){const o=G(e);o&&!i.ignoreOriginalEncoding?r.write(o):a(n,r,t)}function J(e,n,t){if(e===null){n.writeUint8(P);return}if(!t.ignoreOriginalEncoding&&g.ENCODED in e){n.write(e[g.ENCODED]);return}const r=m.get(e.constructor);if(r){const o=r(e,n,t);o&&((typeof o[0]=="bigint"||isFinite(Number(o[0])))&&U(o[0],n,t),b(o[1],n,t));return}if(typeof e.toCBOR=="function"){const o=e.toCBOR(n,t);o&&((typeof o[0]=="bigint"||isFinite(Number(o[0])))&&U(o[0],n,t),b(o[1],n,t));return}if(typeof e.toJSON=="function"){b(e.toJSON(),n,t);return}const i=Object.entries(e).map(o=>[o[0],o[1],Y(o[0],t)]);t.sortKeys&&i.sort(t.sortKeys),F(e,i.length,s.MAP,n,t);for(const[o,d,f]of i)n.write(f),b(d,n,t)}function b(e,n,t){switch(typeof e){case"number":z(e,n,t);break;case"bigint":l(e,n,t);break;case"string":K(e,n,t);break;case"boolean":n.writeUint8(e?C:j);break;case"undefined":if(t.rejectUndefined)throw new Error("Attempt to encode unwanted undefined.");n.writeUint8(W);break;case"object":J(e,n,t);break;case"symbol":throw new TypeError(`Unknown symbol: ${e.toString()}`);default:throw new TypeError(`Unknown type: ${typeof e}, ${String(e)}`)}}function Y(e,n={}){const t={...k};n.dcbor?Object.assign(t,$):n.cde&&Object.assign(t,R),Object.assign(t,n);const r=new N(t);return b(e,r,t),r.read()}function oe(e,n,t=s.POS_INT){n||(n="f");const r={...k,collapseBigInts:!1,chunkSize:10,simplifyNegativeZero:!1},i=new N(r),o=Number(e);function d(f){if(Object.is(e,-0))throw new Error("Invalid integer: -0");const[c,E]=I(e);if(E&&t!==s.POS_INT)throw new Error("Invalid major type combination");const w=typeof f=="number"&&isFinite(f);if(w&&!Number.isSafeInteger(o))throw new TypeError(`Unsafe number for ${n}: ${e}`);if(c>f)throw new TypeError(`Undersized encoding ${n} for: ${e}`);const y=(E?s.NEG_INT:t)<<5;return w?[y,Number(c)]:[y,c]}switch(n){case"bigint":if(Object.is(e,-0))throw new TypeError("Invalid bigint: -0");e=BigInt(e),l(e,i,r);break;case"f":p(o,i,r);break;case"f16":{const f=S(o);if(f===null)throw new TypeError(`Invalid f16: ${e}`);i.writeUint8(O),i.writeUint16(f);break}case"f32":if(!isNaN(o)&&Math.fround(o)!==o)throw new TypeError(`Invalid f32: ${e}`);i.writeUint8(h),i.writeFloat32(o);break;case"f64":i.writeUint8(B),i.writeFloat64(o);break;case"i":if(Object.is(e,-0))throw new Error("Invalid integer: -0");if(Number.isSafeInteger(o))a(o,i,e<0?void 0:t);else{const[f,c]=d(1/0);c>0xffffffffffffffffn?(e=BigInt(e),l(e,i,r)):(i.writeUint8(f|u.EIGHT),i.writeBigUint64(BigInt(c)))}break;case"i0":{const[f,c]=d(23);i.writeUint8(f|c);break}case"i8":{const[f,c]=d(255);i.writeUint8(f|u.ONE),i.writeUint8(c);break}case"i16":{const[f,c]=d(65535);i.writeUint8(f|u.TWO),i.writeUint16(c);break}case"i32":{const[f,c]=d(4294967295);i.writeUint8(f|u.FOUR),i.writeUint32(c);break}case"i64":{const[f,c]=d(0xffffffffffffffffn);i.writeUint8(f|u.EIGHT),i.writeBigUint64(BigInt(c));break}default:throw new TypeError(`Invalid number encoding: "${n}"`)}return _(e,i.read())}export{te as ENCODED,R as cdeEncodeOptions,re as clearEncoder,$ as dcborEncodeOptions,k as defaultEncodeOptions,Y as encode,oe as encodedNumber,ie as registerEncoder,H as writeArray,l as writeBigInt,p as writeFloat,a as writeInt,F as writeLength,z as writeNumber,K as writeString,U as writeTag,Z as writeUint8Array,b as writeUnknown};
